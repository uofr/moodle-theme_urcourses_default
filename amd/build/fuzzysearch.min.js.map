{"version":3,"file":"fuzzysearch.min.js","sources":["../src/fuzzysearch.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Theme Boost Campus - Partial string matching algorithm.\n *\n * Stores a dictionary of words.\n * Predicts partial strings based on words in dictionary. Returns the words most similar to the partial string.\n *\n * @module    theme_urcourses_default/fuzzysearch\n * @author John Lane\n*/\n\n/** @const _GRAM_SIZE_LOWER Gram size lower limit. */\nconst _GRAM_SIZE_LOWER = 2;\n\n/** @const _GRAM_SIZE_UPPER Gram size upper limit. */\nconst _GRAM_SIZE_UPPER = 3;\n\n/** @const _MIN_SCORE Minimum viable score to be considered a potential match. */\nconst _MIN_SCORE = 0;\n\n/** @var _dictionary Stores words and their vector normals for each gram size. */\n/**\n *\n * _dictionary = {\n *      gramSize: [ [normal, word], [normal, word], ... ]\n * };\n *\n */\nlet _dictionary = {};\n\n/** @var _gramMap Stores grams from dictionary words. Grams stored along with where they appear and how often.*/\n/**\n *\n * _gramMap = {\n *      gram: [indexToWord, count]\n * };\n *\n */\nlet _gramMap = {};\n\n/** @var _originals Maps lowercase words to their original version. */\n/**\n *\n * _originals = {\n *      word: original,\n *      word: original,\n *      ...\n * };\n *\n */\nlet _originals = {};\n\n/**\n * Set dictionary to be used in @see search().\n * @param {Array} dictionary A list of words.\n*/\nconst setDictionary = (dictionary) => {\n    if (_dictionary) {\n        _dictionary = {};\n        _gramMap = {};\n        _originals = {};\n    }\n\n    dictionary.forEach(function(word) {\n        for (let gramSize = _GRAM_SIZE_LOWER; gramSize < _GRAM_SIZE_UPPER + 1; gramSize++) {\n            addWord(word, gramSize);\n        }\n    });\n};\n\n/**\n * Stores the specified word.\n * @param {String} word Word to add to dictionaries.\n * @param {Number} gramSize Gram size to use.\n */\nconst addWord = (word, gramSize = 3) => {\n    const wordLower = word.toLowerCase();\n    const grams = getGrams(word, gramSize);\n    const wordNormal = getVectorNormal(grams);\n\n    // save the original word\n    _originals[wordLower] = word;\n\n    // save word along with magnitude for the given gram size\n    if (_dictionary[gramSize]) {\n        _dictionary[gramSize].push([wordNormal, wordLower]);\n    } else {\n        _dictionary[gramSize] = [[wordNormal, wordLower]];\n    }\n\n    // store grams along with where their word appears in the dictionary\n    const wordIndex = _dictionary[gramSize].length - 1;\n    for (const gram in grams) {\n        const gramCount = grams[gram];\n        if (gram in _gramMap) {\n            _gramMap[gram].push([wordIndex, gramCount]);\n        } else {\n            _gramMap[gram] = [[wordIndex, gramCount]];\n        }\n    }\n};\n\n/**\n * Search dictionary for potential matches of @param word.\n * @param {String} word\n * @return {Array} Array of potential matches ordered from most to least likely. Original words are returned.\n */\nconst search = (word) => {\n    for (let gramSize = _GRAM_SIZE_UPPER; gramSize >= _GRAM_SIZE_LOWER; gramSize--) {\n        const results = lookup(word, gramSize);\n        if (results) {return results.map(result => _originals[result[1]]);}\n    }\n    return null;\n};\n\n/**\n * Lookup the word at the given gram size.\n * @param {String} word\n * @param {Number} gramSize\n * @return {Array} Array of words and their score [[score, word], [score, word], ...]\n */\nconst lookup = (word, gramSize) => {\n    const grams = getGrams(word, gramSize);\n    const wordNormal = getVectorNormal(grams);\n    const matches = {}; // matches stores the index of each potential match and the associated dot product\n    const dict = _dictionary[gramSize]; // dictionary of words for the given gram size\n    const results = [];\n\n    for (const gram in grams) {\n        const gramCount = grams[gram];\n        if (gram in _gramMap) { // if gram is in _gramMap, there are potential matching words\n            for (const [index, count] of _gramMap[gram]) { // for each gram in the map, get the index of the match and count\n                // get the dot product of the two vectors\n                if (index in matches) {\n                    matches[index] += gramCount * count;\n                } else {\n                    matches[index] = gramCount * count;\n                }\n            }\n        }\n    }\n\n    if (!matches) {return null; }// if there are no potential matches, return null\n\n    // for each potential match, calculate the cosine similarity score (divide dot product by the product of each normal)\n    for (const matchIndex in matches) {\n        const dotProduct = matches[matchIndex];\n        const [matchNormal, matchingWord] = dict[matchIndex];\n        const crossProduct = wordNormal * matchNormal;\n        const cosineSimilarity = dotProduct / crossProduct;\n        results.push([cosineSimilarity, matchingWord]);\n    }\n\n    return results.sort((a, b) => b[0] - a[0]).filter((match) => match[0] >= _MIN_SCORE);\n};\n\n/**\n * Calculate a word's vector normal from its grams.\n * @param {String} grams  Grams of word who's vector normal will be calculated.\n * @return {Number} Vector normal of word.\n */\nconst getVectorNormal = (grams) => {\n    let sumOfSquareOfGramCounts = 0;\n    for (const gram in grams) {\n        const gramCount = grams[gram];\n        sumOfSquareOfGramCounts += Math.pow(gramCount, 2);\n    }\n    return Math.sqrt(sumOfSquareOfGramCounts);\n};\n\n/**\n * Converts a string into a map of grams and their associated counts.\n *\n * @param {String} string String to be split.\n * @param {Number} gramSize Size of the substrings (grams).\n * @returns {Object} A map of grams along with how many times they appear in the string (ie: {gram: count...)\n */\nconst getGrams = (string, gramSize = 3) => {\n    const gramMap = {};\n    const stringConverted = convertString(string, gramSize);\n\n    for (let i = 0; i < stringConverted.length - gramSize + 1; i++) {\n        const gram = stringConverted.slice(i, i + gramSize);\n        if (gram in gramMap) {\n            gramMap[gram] += 1;\n        } else {\n            gramMap[gram] = 1;\n        }\n    }\n\n    return gramMap;\n};\n\n/**\n * Converts string into a format which can be used by @see getGrams\n * Adds '-' to the start and end of a string, removes non-word characters.\n * If the string is smaller than the gramSize, '-'s are added to the end until the lengths match.\n *\n * @param {String} string - The string to be converted.\n * @param {Number} gramSize - Length of grams.\n * @returns {String} - String converted into a format that can be used by getGrams.\n */\nconst convertString = (string, gramSize = 3) => {\n    const nonWordRegex = /[^a-zA-Z0-9\\u00C0-\\u00FF, ]+/g;\n    const newString = '-' + string.toLowerCase().replace(nonWordRegex, '') + '-';\n    if (newString.length < gramSize) {\n        const lengthDifference = gramSize - string.length;\n        return newString.padEnd((newString.length + lengthDifference), '-');\n    } else {\n        return newString;\n    }\n};\n\nexport default {\n    setDictionary: setDictionary,\n    search: search\n};"],"names":["_GRAM_SIZE_LOWER","_dictionary","_gramMap","_originals","addWord","word","gramSize","wordLower","toLowerCase","grams","getGrams","wordNormal","getVectorNormal","push","wordIndex","length","gram","gramCount","lookup","matches","dict","results","_step","_iterator","s","n","done","_step$value","_slicedToArray","value","index","count","err","e","f","matchIndex","dotProduct","matchNormal","_dict$matchIndex","matchingWord","cosineSimilarity","sort","a","b","filter","match","sumOfSquareOfGramCounts","Math","pow","sqrt","string","gramMap","stringConverted","convertString","i","slice","nonWordRegex","newString","replace","lengthDifference","padEnd","_default","setDictionary","dictionary","forEach","_GRAM_SIZE_UPPER","search","map","result"],"mappings":"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"}