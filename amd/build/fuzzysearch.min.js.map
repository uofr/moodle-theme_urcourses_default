{"version":3,"file":"fuzzysearch.min.js","sources":["../src/fuzzysearch.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Theme Boost Campus - Partial string matching algorithm.\n *\n * Stores a dictionary of words.\n * Predicts partial strings based on words in dictionary. Returns the words most similar to the partial string.\n *\n * @module    theme_urcourses_default/fuzzysearch\n * @author John Lane\n*/\n\n/** @const _GRAM_SIZE_LOWER Gram size lower limit. */\nconst _GRAM_SIZE_LOWER = 2;\n\n/** @const _GRAM_SIZE_UPPER Gram size upper limit. */\nconst _GRAM_SIZE_UPPER = 3;\n\n/** @const _MIN_SCORE Minimum viable score to be considered a potential match. */\nconst _MIN_SCORE = 0;\n\n/** @var _dictionary Stores words and their vector normals for each gram size. */\n/**\n *\n * _dictionary = {\n *      gramSize: [ [normal, word], [normal, word], ... ]\n * };\n *\n */\nlet _dictionary = {};\n\n/** @var _gramMap Stores grams from dictionary words. Grams stored along with where they appear and how often.*/\n/**\n *\n * _gramMap = {\n *      gram: [indexToWord, count]\n * };\n *\n */\nlet _gramMap = {};\n\n/** @var _originals Maps lowercase words to their original version. */\n/**\n *\n * _originals = {\n *      word: original,\n *      word: original,\n *      ...\n * };\n *\n */\nlet _originals = {};\n\n/**\n * Set dictionary to be used in @see search().\n * @param {Array} dictionary A list of words.\n*/\nconst setDictionary = (dictionary) => {\n    if (_dictionary) {\n        _dictionary = {};\n        _gramMap = {};\n        _originals = {};\n    }\n\n    dictionary.forEach(function(word) {\n        for (let gramSize = _GRAM_SIZE_LOWER; gramSize < _GRAM_SIZE_UPPER + 1; gramSize++) {\n            addWord(word, gramSize);\n        }\n    });\n};\n\n/**\n * Stores the specified word.\n * @param {String} word Word to add to dictionaries.\n * @param {Number} gramSize Gram size to use.\n */\nconst addWord = (word, gramSize = 3) => {\n    const wordLower = word.toLowerCase();\n    const grams = getGrams(word, gramSize);\n    const wordNormal = getVectorNormal(grams);\n\n    // save the original word\n    _originals[wordLower] = word;\n\n    // save word along with magnitude for the given gram size\n    if (_dictionary[gramSize]) {\n        _dictionary[gramSize].push([wordNormal, wordLower]);\n    } else {\n        _dictionary[gramSize] = [[wordNormal, wordLower]];\n    }\n\n    // store grams along with where their word appears in the dictionary\n    const wordIndex = _dictionary[gramSize].length - 1;\n    for (const gram in grams) {\n        const gramCount = grams[gram];\n        if (gram in _gramMap) {\n            _gramMap[gram].push([wordIndex, gramCount]);\n        } else {\n            _gramMap[gram] = [[wordIndex, gramCount]];\n        }\n    }\n};\n\n/**\n * Search dictionary for potential matches of @param word.\n * @param {String} word\n * @return {Array} Array of potential matches ordered from most to least likely. Original words are returned.\n */\nconst search = (word) => {\n    for (let gramSize = _GRAM_SIZE_UPPER; gramSize >= _GRAM_SIZE_LOWER; gramSize--) {\n        const results = lookup(word, gramSize);\n        if (results) {return results.map(result => _originals[result[1]]);}\n    }\n    return null;\n};\n\n/**\n * Lookup the word at the given gram size.\n * @param {String} word\n * @param {Number} gramSize\n * @return {Array} Array of words and their score [[score, word], [score, word], ...]\n */\nconst lookup = (word, gramSize) => {\n    const grams = getGrams(word, gramSize);\n    const wordNormal = getVectorNormal(grams);\n    const matches = {}; // matches stores the index of each potential match and the associated dot product\n    const dict = _dictionary[gramSize]; // dictionary of words for the given gram size\n    const results = [];\n\n    for (const gram in grams) {\n        const gramCount = grams[gram];\n        if (gram in _gramMap) { // if gram is in _gramMap, there are potential matching words\n            for (const [index, count] of _gramMap[gram]) { // for each gram in the map, get the index of the match and count\n                // get the dot product of the two vectors\n                if (index in matches) {\n                    matches[index] += gramCount * count;\n                } else {\n                    matches[index] = gramCount * count;\n                }\n            }\n        }\n    }\n\n    if (!matches) {return null; }// if there are no potential matches, return null\n\n    // for each potential match, calculate the cosine similarity score (divide dot product by the product of each normal)\n    for (const matchIndex in matches) {\n        const dotProduct = matches[matchIndex];\n        const [matchNormal, matchingWord] = dict[matchIndex];\n        const crossProduct = wordNormal * matchNormal;\n        const cosineSimilarity = dotProduct / crossProduct;\n        results.push([cosineSimilarity, matchingWord]);\n    }\n\n    return results.sort((a, b) => b[0] - a[0]).filter((match) => match[0] >= _MIN_SCORE);\n};\n\n/**\n * Calculate a word's vector normal from its grams.\n * @param {String} grams  Grams of word who's vector normal will be calculated.\n * @return {Number} Vector normal of word.\n */\nconst getVectorNormal = (grams) => {\n    let sumOfSquareOfGramCounts = 0;\n    for (const gram in grams) {\n        const gramCount = grams[gram];\n        sumOfSquareOfGramCounts += Math.pow(gramCount, 2);\n    }\n    return Math.sqrt(sumOfSquareOfGramCounts);\n};\n\n/**\n * Converts a string into a map of grams and their associated counts.\n *\n * @param {String} string String to be split.\n * @param {Number} gramSize Size of the substrings (grams).\n * @returns {Object} A map of grams along with how many times they appear in the string (ie: {gram: count...)\n */\nconst getGrams = (string, gramSize = 3) => {\n    const gramMap = {};\n    const stringConverted = convertString(string, gramSize);\n\n    for (let i = 0; i < stringConverted.length - gramSize + 1; i++) {\n        const gram = stringConverted.slice(i, i + gramSize);\n        if (gram in gramMap) {\n            gramMap[gram] += 1;\n        } else {\n            gramMap[gram] = 1;\n        }\n    }\n\n    return gramMap;\n};\n\n/**\n * Converts string into a format which can be used by @see getGrams\n * Adds '-' to the start and end of a string, removes non-word characters.\n * If the string is smaller than the gramSize, '-'s are added to the end until the lengths match.\n *\n * @param {String} string - The string to be converted.\n * @param {Number} gramSize - Length of grams.\n * @returns {String} - String converted into a format that can be used by getGrams.\n */\nconst convertString = (string, gramSize = 3) => {\n    const nonWordRegex = /[^a-zA-Z0-9\\u00C0-\\u00FF, ]+/g;\n    const newString = '-' + string.toLowerCase().replace(nonWordRegex, '') + '-';\n    if (newString.length < gramSize) {\n        const lengthDifference = gramSize - string.length;\n        return newString.padEnd((newString.length + lengthDifference), '-');\n    } else {\n        return newString;\n    }\n};\n\nexport default {\n    setDictionary: setDictionary,\n    search: search\n};"],"names":["_dictionary","_gramMap","_originals","addWord","word","gramSize","wordLower","toLowerCase","grams","getGrams","wordNormal","getVectorNormal","push","wordIndex","length","gram","gramCount","lookup","matches","dict","results","index","count","matchIndex","dotProduct","matchNormal","matchingWord","cosineSimilarity","sort","a","b","filter","match","sumOfSquareOfGramCounts","Math","pow","sqrt","string","gramMap","stringConverted","convertString","i","slice","nonWordRegex","newString","replace","lengthDifference","padEnd","setDictionary","dictionary","forEach","_GRAM_SIZE_UPPER","search","map","result"],"mappings":"4mEA0CIA,YAAc,GAUdC,SAAW,GAYXC,WAAa,GAyBXC,QAAU,SAACC,UAAMC,gEAAW,EACxBC,UAAYF,KAAKG,cACjBC,MAAQC,SAASL,KAAMC,UACvBK,WAAaC,gBAAgBH,OAGnCN,WAAWI,WAAaF,KAGpBJ,YAAYK,UACZL,YAAYK,UAAUO,KAAK,CAACF,WAAYJ,YAExCN,YAAYK,UAAY,CAAC,CAACK,WAAYJ,gBAIpCO,UAAYb,YAAYK,UAAUS,OAAS,MAC5C,IAAMC,QAAQP,MAAO,KAChBQ,UAAYR,MAAMO,MACpBA,QAAQd,SACRA,SAASc,MAAMH,KAAK,CAACC,UAAWG,YAEhCf,SAASc,MAAQ,CAAC,CAACF,UAAWG,cAwBpCC,OAAS,SAACb,KAAMC,cACZG,MAAQC,SAASL,KAAMC,UACvBK,WAAaC,gBAAgBH,OAC7BU,QAAU,GACVC,KAAOnB,YAAYK,UACnBe,QAAU,OAEX,IAAML,QAAQP,MAAO,KAChBQ,UAAYR,MAAMO,SACpBA,QAAQd,SAAU,gDACWA,SAASc,0DAAO,+CAAjCM,qBAAOC,qBAEXD,SAASH,QACTA,QAAQG,QAAUL,UAAYM,MAE9BJ,QAAQG,OAASL,UAAYM,+DAMxCJ,eAAiB,SAGjB,IAAMK,cAAcL,QAAS,KACxBM,WAAaN,QAAQK,4CACSJ,KAAKI,eAAlCE,gCAAaC,iCAEdC,iBAAmBH,YADJd,WAAae,aAElCL,QAAQR,KAAK,CAACe,iBAAkBD,sBAG7BN,QAAQQ,MAAK,SAACC,EAAGC,UAAMA,EAAE,GAAKD,EAAE,MAAIE,QAAO,SAACC,cAAUA,MAAM,IAvIpD,MA+IbrB,gBAAkB,SAACH,WACjByB,wBAA0B,MACzB,IAAMlB,QAAQP,MAAO,KAChBQ,UAAYR,MAAMO,MACxBkB,yBAA2BC,KAAKC,IAAInB,UAAW,UAE5CkB,KAAKE,KAAKH,0BAUfxB,SAAW,SAAC4B,gBAAQhC,gEAAW,EAC3BiC,QAAU,GACVC,gBAAkBC,cAAcH,OAAQhC,UAErCoC,EAAI,EAAGA,EAAIF,gBAAgBzB,OAAST,SAAW,EAAGoC,IAAK,KACtD1B,KAAOwB,gBAAgBG,MAAMD,EAAGA,EAAIpC,UACtCU,QAAQuB,QACRA,QAAQvB,OAAS,EAEjBuB,QAAQvB,MAAQ,SAIjBuB,SAYLE,cAAgB,SAACH,YAAQhC,gEAAW,EAChCsC,aAAe,gCACfC,UAAY,IAAMP,OAAO9B,cAAcsC,QAAQF,aAAc,IAAM,OACrEC,UAAU9B,OAAST,SAAU,KACvByC,iBAAmBzC,SAAWgC,OAAOvB,cACpC8B,UAAUG,OAAQH,UAAU9B,OAASgC,iBAAmB,YAExDF,oBAIA,CACXI,cA9JkB,SAACC,YACfjD,cACAA,YAAc,GACdC,SAAW,GACXC,WAAa,IAGjB+C,WAAWC,SAAQ,SAAS9C,UACnB,IAAIC,SApDQ,EAoDqBA,SAAW8C,EAAsB9C,WACnEF,QAAQC,KAAMC,cAsJtB+C,OA5GW,SAAChD,UACP,IAAIC,SA7FY,EA6FiBA,UAhGjB,EAgG+CA,WAAY,KACtEe,QAAUH,OAAOb,KAAMC,aACzBe,eAAiBA,QAAQiC,KAAI,SAAAC,eAAUpD,WAAWoD,OAAO,cAE1D"}